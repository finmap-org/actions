name: Aggregate
description: Composite Github Action

inputs:
  repo:
    required: true
  start_date:
    description: 'Start date, YYYY/MM/DD'
    required: true
  end_date:
    description: 'End date, YYYY/MM/DD'
    required: true

runs:
  using: "composite"
  steps:
    - name: Read Inputs
      shell: bash
      run: |
        # Convert input dates into YYYY/MM/DD
        START_DATE=$(date -d "${{ inputs.start_date }}" +%Y/%m/%d)
        END_DATE=$(date -d "${{ inputs.end_date }}" +%Y/%m/%d)
        echo "START_DATE=$START_DATE" >> $GITHUB_ENV
        echo "END_DATE=$END_DATE" >> $GITHUB_ENV

        REPO="${{ inputs.repo }}"
        echo "REPO=$REPO" >> $GITHUB_ENV

    - name: Calculate sector aggregates
      shell: bash
      run: |
        set -euo pipefail

        # Enable nullglob so that if no *.json files exist in "$data_dir/*.json",
        # the glob expands to an empty list and the loop is skipped instead of
        # processing the literal pattern string
        shopt -s nullglob

        function sector_sum() {
          local json="$1"
          local exchange="$2"
          local currency="$3"

          local TMP="$(mktemp)"

          jq --arg exchange "$exchange" \
             --arg currency "$currency" \
           'def current_total(g): g | map(.[17]) | add;
            def prev_total(g): g | map(.[17] / (1 + (.[13] // 0) / 100)) | add;
            def pct(g): if prev_total(g) == 0 then 0 else ((current_total(g) - prev_total(g)) / prev_total(g) * 100) end;
            .securities.data += (.securities.data | group_by(.[3]) | map(
              [
                "",
                "",
                "sector",
                $exchange,
                "",
                $currency,
                .[0][3],
                .[0][3],
                "",
                "",
                "",
                0,
                0,
                pct(.),
                (map(.[14]) | add),
                (map(.[15]) | add),
                (map(.[16]) | add),
                current_total(.),
                "",
                "",
                "",
                "",
                length
              ]
            ))' "$json" > "$TMP" && mv "$TMP" "$json"

          rm -rf $TMP
        }

        function market_totals() {
          local json="$1"
          local exchange="$2"
          local currency="$3"

          local TMP="$(mktemp)"
          
          jq --arg exchange "$exchange" \
             --arg currency "$currency" \
            'def securities: .securities.data | map(select(.[2] != "sector"));
             def total_current: securities | map(.[17]) | add;
             def total_prev: securities | map(.[17] / (1 + (.[13] // 0) / 100)) | add;
             def total_pct: if total_prev == 0 then 0 else ((total_current - total_prev) / total_prev * 100) end;
             .securities.data += [
               [
                 "",
                 "",
                 "sector",
                 "",
                 "",
                 $currency,
                 $exchange,
                 $exchange,
                 "",
                 "",
                 "",
                 0,
                 0,
                 total_pct,
                 (securities | map(.[14]) | add),
                 (securities | map(.[15]) | add),
                 (securities | map(.[16]) | add),
                 total_current,
                 "",
                 "",
                 "",
                 "",
                 (securities | length)
               ]
             ]' "$json" > "$TMP" && mv "$TMP" "$json"

          rm -rf $TMP
        }

        function aggregate() {
          local current_date="$1"
          local data_dir="${{ github.workspace }}/${REPO}/marketdata/${current_date}"

          for json in $data_dir/*.json; do
            exchange=$(jq -r '.securities.data[0] | .[0]' "$json")
            currency=$(jq -r '.securities.data[0] | .[5]' "$json")
            sector_sum "$json" "$exchange" "$currency"
            market_totals "$json" "$exchange" "$currency"
          done
        }

        # Convert dates to seconds since epoch for comparison
        start_seconds=$(date -d "$START_DATE" +%s)
        end_seconds=$(date -d "$END_DATE" +%s)
        
        max_jobs=10

        # Loop through the date range
        current_seconds=$start_seconds
        while [ $current_seconds -le $end_seconds ]; do
          current_date=$(date -d "@$current_seconds" +"%Y/%m/%d")
          # Increment the current date by one day (86400 seconds)
          current_seconds=$((current_seconds + 86400))
        
          # Skip weekends
          if [ $(date -d "$current_date" +%u) -ge 6 ]; then
            continue
          fi

          aggregate "$current_date" &

          while (( $(jobs -r | wc -l) >= max_jobs )); do
            wait -n  # Wait for any one job to finish if max concurrent jobs reached
          done
        done

        # Wait for all background jobs to finish
        wait